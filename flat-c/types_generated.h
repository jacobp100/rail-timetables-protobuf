// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TYPES_H_
#define FLATBUFFERS_GENERATED_TYPES_H_

#include "flatbuffers/flatbuffers.h"

struct Stop;

struct Route;

struct Root;

struct Stop FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STATIONID = 4,
    VT_ARRIVALTIME = 6,
    VT_DEPARTURETIME = 8,
    VT_PLATFORM = 10
  };
  uint16_t stationId() const {
    return GetField<uint16_t>(VT_STATIONID, 0);
  }
  uint16_t arrivalTime() const {
    return GetField<uint16_t>(VT_ARRIVALTIME, 0);
  }
  uint16_t departureTime() const {
    return GetField<uint16_t>(VT_DEPARTURETIME, 0);
  }
  const flatbuffers::String *platform() const {
    return GetPointer<const flatbuffers::String *>(VT_PLATFORM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_STATIONID) &&
           VerifyField<uint16_t>(verifier, VT_ARRIVALTIME) &&
           VerifyField<uint16_t>(verifier, VT_DEPARTURETIME) &&
           VerifyOffset(verifier, VT_PLATFORM) &&
           verifier.Verify(platform()) &&
           verifier.EndTable();
  }
};

struct StopBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stationId(uint16_t stationId) {
    fbb_.AddElement<uint16_t>(Stop::VT_STATIONID, stationId, 0);
  }
  void add_arrivalTime(uint16_t arrivalTime) {
    fbb_.AddElement<uint16_t>(Stop::VT_ARRIVALTIME, arrivalTime, 0);
  }
  void add_departureTime(uint16_t departureTime) {
    fbb_.AddElement<uint16_t>(Stop::VT_DEPARTURETIME, departureTime, 0);
  }
  void add_platform(flatbuffers::Offset<flatbuffers::String> platform) {
    fbb_.AddOffset(Stop::VT_PLATFORM, platform);
  }
  explicit StopBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StopBuilder &operator=(const StopBuilder &);
  flatbuffers::Offset<Stop> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Stop>(end);
    return o;
  }
};

inline flatbuffers::Offset<Stop> CreateStop(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stationId = 0,
    uint16_t arrivalTime = 0,
    uint16_t departureTime = 0,
    flatbuffers::Offset<flatbuffers::String> platform = 0) {
  StopBuilder builder_(_fbb);
  builder_.add_platform(platform);
  builder_.add_departureTime(departureTime);
  builder_.add_arrivalTime(arrivalTime);
  builder_.add_stationId(stationId);
  return builder_.Finish();
}

inline flatbuffers::Offset<Stop> CreateStopDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t stationId = 0,
    uint16_t arrivalTime = 0,
    uint16_t departureTime = 0,
    const char *platform = nullptr) {
  return CreateStop(
      _fbb,
      stationId,
      arrivalTime,
      departureTime,
      platform ? _fbb.CreateString(platform) : 0);
}

struct Route FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ROUTEID = 4,
    VT_OPERATINGDAYS = 6,
    VT_DATEFROM = 8,
    VT_DATETO = 10,
    VT_STOPS = 12
  };
  uint16_t routeId() const {
    return GetField<uint16_t>(VT_ROUTEID, 0);
  }
  uint8_t operatingDays() const {
    return GetField<uint8_t>(VT_OPERATINGDAYS, 0);
  }
  uint16_t dateFrom() const {
    return GetField<uint16_t>(VT_DATEFROM, 0);
  }
  uint16_t dateTo() const {
    return GetField<uint16_t>(VT_DATETO, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Stop>> *stops() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Stop>> *>(VT_STOPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ROUTEID) &&
           VerifyField<uint8_t>(verifier, VT_OPERATINGDAYS) &&
           VerifyField<uint16_t>(verifier, VT_DATEFROM) &&
           VerifyField<uint16_t>(verifier, VT_DATETO) &&
           VerifyOffset(verifier, VT_STOPS) &&
           verifier.Verify(stops()) &&
           verifier.VerifyVectorOfTables(stops()) &&
           verifier.EndTable();
  }
};

struct RouteBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_routeId(uint16_t routeId) {
    fbb_.AddElement<uint16_t>(Route::VT_ROUTEID, routeId, 0);
  }
  void add_operatingDays(uint8_t operatingDays) {
    fbb_.AddElement<uint8_t>(Route::VT_OPERATINGDAYS, operatingDays, 0);
  }
  void add_dateFrom(uint16_t dateFrom) {
    fbb_.AddElement<uint16_t>(Route::VT_DATEFROM, dateFrom, 0);
  }
  void add_dateTo(uint16_t dateTo) {
    fbb_.AddElement<uint16_t>(Route::VT_DATETO, dateTo, 0);
  }
  void add_stops(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Stop>>> stops) {
    fbb_.AddOffset(Route::VT_STOPS, stops);
  }
  explicit RouteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RouteBuilder &operator=(const RouteBuilder &);
  flatbuffers::Offset<Route> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Route>(end);
    return o;
  }
};

inline flatbuffers::Offset<Route> CreateRoute(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t routeId = 0,
    uint8_t operatingDays = 0,
    uint16_t dateFrom = 0,
    uint16_t dateTo = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Stop>>> stops = 0) {
  RouteBuilder builder_(_fbb);
  builder_.add_stops(stops);
  builder_.add_dateTo(dateTo);
  builder_.add_dateFrom(dateFrom);
  builder_.add_routeId(routeId);
  builder_.add_operatingDays(operatingDays);
  return builder_.Finish();
}

inline flatbuffers::Offset<Route> CreateRouteDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t routeId = 0,
    uint8_t operatingDays = 0,
    uint16_t dateFrom = 0,
    uint16_t dateTo = 0,
    const std::vector<flatbuffers::Offset<Stop>> *stops = nullptr) {
  return CreateRoute(
      _fbb,
      routeId,
      operatingDays,
      dateFrom,
      dateTo,
      stops ? _fbb.CreateVector<flatbuffers::Offset<Stop>>(*stops) : 0);
}

struct Root FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ROUTES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Route>> *routes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Route>> *>(VT_ROUTES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROUTES) &&
           verifier.Verify(routes()) &&
           verifier.VerifyVectorOfTables(routes()) &&
           verifier.EndTable();
  }
};

struct RootBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_routes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Route>>> routes) {
    fbb_.AddOffset(Root::VT_ROUTES, routes);
  }
  explicit RootBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RootBuilder &operator=(const RootBuilder &);
  flatbuffers::Offset<Root> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Root>(end);
    return o;
  }
};

inline flatbuffers::Offset<Root> CreateRoot(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Route>>> routes = 0) {
  RootBuilder builder_(_fbb);
  builder_.add_routes(routes);
  return builder_.Finish();
}

inline flatbuffers::Offset<Root> CreateRootDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Route>> *routes = nullptr) {
  return CreateRoot(
      _fbb,
      routes ? _fbb.CreateVector<flatbuffers::Offset<Route>>(*routes) : 0);
}

inline const Root *GetRoot(const void *buf) {
  return flatbuffers::GetRoot<Root>(buf);
}

inline const Root *GetSizePrefixedRoot(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Root>(buf);
}

inline bool VerifyRootBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Root>(nullptr);
}

inline bool VerifySizePrefixedRootBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Root>(nullptr);
}

inline void FinishRootBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Root> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedRootBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Root> root) {
  fbb.FinishSizePrefixed(root);
}

#endif  // FLATBUFFERS_GENERATED_TYPES_H_
